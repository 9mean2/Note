

# 1. 시작하기에 전에

-   **(1) 리-렌더링의 발생 조건**
    
    1.  컴포넌트에서 state가 바뀌었을 때
       
    2.  컴포넌트가 내려받은 props가 변경되었을 때
       
    3.  부모 컴포넌트가 리-렌더링 된 경우 자식 컴포넌트는 모두
       
-   **(2) 최적화**
    
    앞서 useState, useEffect, useRef, useContext 등 많은 훅을 배웠다. 
    
    리액트에서 **리렌더링**이 빈번하게, 자주 일어난다는 것은 그렇게 좋은 소식
    은 아니다 
    
    **비용**이 발생하는 것은 최대한 줄여야 하며 이런 작업을 우리는 `최적화(Optimization)`이라고 부른다.
    
 리액트에서 **불필요한 렌더링**이 발생하지 않도록 최적화하는 대표적인 방법이 바로
    
-   memo(React.memo) : 컴포넌트를 캐싱

-   useCallback : 함수를 캐싱
  
-   useMemo : 값을 캐싱

## 2. memo(React.memo)

-   **(1) memo란?**
    
    리-렌더링의 발생 조건 중 3번째 경우. 즉, 부모 컴포넌트가 리렌더링 되면 자식컴포넌트는 모두 리렌더링 된다

    자녀 컴포넌트의 입장에서는 `“나는 바뀐게 없는데 왜 다시 렌더링 돼야하지?”`라고 할 수 있다. 
    
    이 부분을 돕는 도구가 바로 `React.memo` 이다.
    
-   **(2) 코드를 통해 문제상황 살펴보기**
    
    디렉토리 구성
    ![[스크린샷 2023-02-13 오후 3.46.56.png]]
    
    결과물
    ![[스크린샷 2023-02-13 오후 3.47.35.png]]
    
    App.jsx
    ```jsx
    import React, { useState } from "react";
    import Box1 from "./components/Box1";
    import Box2 from "./components/Box2";
    import Box3 from "./components/Box3";
    
    const boxesStyle = {
      display: "flex",
      marginTop: "10px",
    };
    
    function App() {
      console.log("app컴포 렌더링됐음");
    
      const [count, setCount] = useState(0);
    
      // 1을 증가시키는 함수
      const onPlusButtonClickHandler = () => {
        setCount(count + 1);
      };
    
      // 1을 감소시키는 함수
      const onMinusButtonClickHandler = () => {
        setCount(count - 1);
      };
    
      return (
        <>
          <h3>카운트 예제입니다! ! !</h3>
          <p>현재 카운트 : {count}</p>
          <button onClick={onPlusButtonClickHandler}>+</button>
          <button onClick={onMinusButtonClickHandler}>-</button>
          <div style={boxesStyle}>
            <Box1 />
            <Box2 />
            <Box3 />
          </div>
        </>
      );
    }
    
    export default App;
    ```
    
    Box1.jsx
    ```jsx
    import React from "react";
    
    const boxStyle = {
      width: "100px",
      height: "100px",
      backgroundColor: "#91c49f",
      color: "white",
    
      // 가운데 정렬 3종세트
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
    };
    
    function Box1() {
      console.log("Box1이 렌더링되었습니다.");
      return <div style={boxStyle}>Box1</div>;
    }
    
    export default Box1;
    ```
    
    Box2.jsx
    ```jsx
    import React from "react";
    
    const boxStyle = {
      width: "100px",
      height: "100px",
      backgroundColor: "#4e93ed",
      color: "white",
    
      // 가운데 정렬 3종세트
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
    };
    
    function Box2() {
      console.log("Box2가 렌더링되었습니다.");
      return <div style={boxStyle}>Box2</div>;
    }
    
    export default Box2;
    ```
    
    Box3.jsx
    ```jsx
    import React from "react";
    
    const boxStyle = {
      width: "100px",
      height: "100px",
      backgroundColor: "#c491be",
      color: "white",
    
      // 가운데 정렬 3종세트
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
    };
    
    function Box3() {
      console.log("Box3가 렌더링되었습니다.");
      return <div style={boxStyle}>Box3</div>;
    }
    
    export default Box3;
    ```
    
    plus 버튼 또는 minus 버튼을 누른다면?
    
    chrome 브라우저
    ![[스크린샷 2023-02-13 오후 3.49.05.png]]
    
    모든 하위 컴포넌트가 리렌더링 되고 있다.
    
    실제로 변한 것은 부모컴포넌트, **`App.jsx`** 뿐이지만
    
-   **(3) memo를 통해 해결해보기**
    
    간단히 `React.memo`를 이용 해 컴포넌트를 메모리에 저장해두고 필요할 때 갖다 쓰게 된다. 
    
    이렇게 하면 부모 컴포넌트의 `state`의 변경으로 인해 `props`가 변경이 일어나지 않는 한 컴포넌트는 **리렌더링 되지 않는다.** 
    
    이것을 `컴포넌트 memoization` 이라고 한다.
    
    Box1.jsx, Box2.jsx, Box3.jsx 모두 동일
    ```jsx
    export default React.memo(Box1);
    export default React.memo(Box2);
    export default React.memo(Box3);
    ```
    
    최초 렌더링 이외에는 App.jsx 컴포넌트의 state가 변경되더라도 자식 컴포넌트들은 렌더링이 되지 않는다.
    
    ![[스크린샷 2023-02-13 오후 3.51.37.png]]
    